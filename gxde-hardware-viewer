#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import sys
import platform
import psutil
import socket
import subprocess
import json
import os
from datetime import datetime
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                            QHBoxLayout, QListWidget, QListWidgetItem, QStackedWidget,
                            QLabel, QGroupBox, QFormLayout, QGridLayout, QScrollArea,
                            QTableWidget, QTableWidgetItem, QProgressBar, QFrame,
                            QPushButton, QMenu, QMessageBox, QFileDialog, QAbstractItemView)
from PyQt6.QtCore import Qt, QTimer, QSize
from PyQt6.QtGui import QIcon, QFont, QFontDatabase

class HardwareManager(QMainWindow):
    def __init__(self):
        super().__init__()
        # 保存需要实时更新的控件引用
        self.cpu_total_bar = None
        self.cpu_core_bars = []
        self.mem_total_bar = None
        self.swap_bar = None
        self.net_io_labels = {}
        self.disk_io_labels = {}
        
        # 初始化UI缩放因子
        self.init_scaling_factor()
        self.initUI()
        self.init_timer()
        
    def init_scaling_factor(self):
        """初始化缩放因子，用于适配不同分辨率"""
        try:
            # 获取屏幕逻辑DPI
            screen = QApplication.primaryScreen()
            dpi = screen.logicalDotsPerInch()
            # 以96 DPI为基准计算缩放因子
            self.scaling_factor = dpi / 96.0
        except:
            # 默认为1.0
            self.scaling_factor = 1.0
            
    def scaled(self, value):
        """根据缩放因子缩放数值"""
        return int(value * self.scaling_factor)
        
    def initUI(self):
        # 设置窗口基本属性
        self.setWindowTitle("GXDE硬件管理器")
        # 使用相对大小而非固定大小
        self.resize(self.scaled(900), self.scaled(600))
        
        # 创建主布局
        main_widget = QWidget()
        main_layout = QHBoxLayout(main_widget)
        
        # 创建侧边栏
        self.sidebar = QListWidget()
        # 侧边栏宽度根据缩放因子调整
        self.sidebar.setFixedWidth(self.scaled(180))
        self.sidebar.setStyleSheet(f"""
            QListWidget {{
                border-right: 1px solid #dcdcdc;
                padding-top: {self.scaled(10)}px;
            }}
            QListWidgetItem {{
                height: {self.scaled(36)}px;
                padding-left: {self.scaled(15)}px;
                font-size: {self.scaled(14)}px;
            }}
            QListWidget::item:selected {{
                color: #2ca7f8;
                border-left: 3px solid #2ca7f8;
            }}
        """)
        
        # 添加侧边栏项目
        self.add_sidebar_item("系统信息", "system")
        self.add_sidebar_item("处理器", "cpu")
        self.add_sidebar_item("内存", "memory")
        self.add_sidebar_item("存储", "disk-quota")
        self.add_sidebar_item("网络", "network")
        self.add_sidebar_item("显示", "display")
        self.add_sidebar_item("声音", "sound")
        self.add_sidebar_item("输入设备", "dialog-input-devices")
        
        # 创建主内容区域
        self.stack = QStackedWidget()
        
        # 添加各个页面
        self.stack.addWidget(self.create_system_info_page())
        self.stack.addWidget(self.create_cpu_page())
        self.stack.addWidget(self.create_memory_page())
        self.stack.addWidget(self.create_storage_page())
        self.stack.addWidget(self.create_network_page())
        self.stack.addWidget(self.create_display_page())
        self.stack.addWidget(self.create_sound_page())
        self.stack.addWidget(self.create_input_page())
        
        # 连接侧边栏选择事件
        self.sidebar.currentRowChanged.connect(self.stack.setCurrentIndex)
        
        # 添加到主布局
        main_layout.addWidget(self.sidebar)
        main_layout.addWidget(self.stack, 1)
        
        # 设置中心部件
        self.setCentralWidget(main_widget)
        
        # 默认选中第一个项目
        self.sidebar.setCurrentRow(0)
        
        # 添加右上角菜单按钮
        self.create_menu_button()
        
        # 应用字体缩放
        self.apply_font_scaling()
        
    def create_menu_button(self):
        """创建右上角菜单按钮"""
        # 创建菜单按钮
        menu_button = QPushButton("☰")
        menu_button.setFixedSize(self.scaled(30), self.scaled(30))
        menu_button.setStyleSheet("""
            QPushButton {
                border: 1px solid #ccc;
                border-radius: 4px;
                font-size: 16px;
                font-weight: bold;
            }
        """)
        
        # 创建菜单
        menu = QMenu()
        menu.setStyleSheet("""
            QMenu {
                border: 1px solid #ccc;
                border-radius: 4px;
            }
            QMenu::item {
                padding: 5px 20px;
            }
        """)
        
        # 添加菜单项
        export_action = menu.addAction("导出所有信息到桌面")
        export_action.triggered.connect(self.export_all_info)
        
        about_action = menu.addAction("关于")
        about_action.triggered.connect(self.show_about)
        
        # 设置按钮菜单
        menu_button.setMenu(menu)
        
        # 将按钮添加到窗口的右上角
        menu_button.setParent(self)
        menu_button.move(self.width() - menu_button.width() - 10, 30)
        
        # 保存按钮引用，以便在窗口大小改变时调整位置
        self.menu_button = menu_button
        
    def resizeEvent(self, event):
        """重写窗口大小改变事件，确保菜单按钮始终在右上角"""
        super().resizeEvent(event)
        if hasattr(self, 'menu_button'):
            self.menu_button.move(self.width() - self.menu_button.width() - 10, 30)
        
    def export_all_info(self):
        """导出所有硬件信息到桌面"""
        try:
            # 收集所有硬件信息
            info = {}
            
            # 系统信息
            uname = platform.uname()
            info['系统信息'] = {
                '操作系统': f"{uname.system} {uname.release} (GXDE)",
                '主机名': uname.node,
                '内核版本': uname.version,
                '系统架构': uname.machine,
                '启动时间': self.get_uptime()
            }
            
            # CPU信息
            cpu_freq = psutil.cpu_freq()
            info['CPU信息'] = {
                '处理器型号': self.get_cpu_model(),
                '架构': platform.machine(),
                '物理核心': psutil.cpu_count(logical=False) or 0,
                '逻辑核心': psutil.cpu_count(logical=True) or 0,
                '当前频率': f"{cpu_freq.current:.2f} MHz" if cpu_freq and cpu_freq.current else "未知",
                '最大频率': f"{cpu_freq.max:.2f} MHz" if cpu_freq and cpu_freq.max else "未知",
                '最小频率': f"{cpu_freq.min:.2f} MHz" if cpu_freq and cpu_freq.min else "未知",
                '驱动信息': self.get_cpu_driver_info()
            }
            
            # 内存信息
            mem = psutil.virtual_memory()
            swap = psutil.swap_memory()
            info['内存信息'] = {
                '总内存': self.format_size(mem.total),
                '已使用': self.format_size(mem.used),
                '空闲': self.format_size(mem.free),
                '可用': self.format_size(mem.available),
                '缓存': self.format_size(mem.total - mem.used - mem.free),
                '内存使用率': f"{mem.percent}%",
                '交换分区总容量': self.format_size(swap.total),
                '交换分区已使用': self.format_size(swap.used),
                '交换分区空闲': self.format_size(swap.free),
                '交换分区使用率': f"{swap.percent}%",
                '内存硬件与驱动': self.get_memory_hardware_info()
            }
            
            # 磁盘信息
            disks = []
            for part in psutil.disk_partitions():
                if 'cdrom' in part.opts or part.fstype == '':
                    continue
                try:
                    disk_usage = psutil.disk_usage(part.mountpoint)
                    disks.append({
                        '设备': part.device,
                        '挂载点': part.mountpoint,
                        '文件系统': part.fstype,
                        '总容量': self.format_size(disk_usage.total),
                        '可用空间': self.format_size(disk_usage.free)
                    })
                except PermissionError:
                    continue
            info['磁盘信息'] = disks
            info['存储设备与驱动'] = self.get_storage_devices_info()
            
            # 网络信息
            net_if_addrs = psutil.net_if_addrs()
            net_if_stats = psutil.net_if_stats()
            network_interfaces = []
            for iface in net_if_addrs:
                # 获取IP地址
                ip_address = "无"
                for addr in net_if_addrs[iface]:
                    if addr.family == socket.AF_INET:
                        ip_address = addr.address
                        break
                        
                # 获取MAC地址
                mac_address = "无"
                for addr in net_if_addrs[iface]:
                    if hasattr(addr, 'family') and addr.family == psutil.AF_LINK:
                        mac_address = addr.address
                        break
                        
                # 获取状态
                status = "未知"
                if iface in net_if_stats:
                    status = "已连接" if net_if_stats[iface].isup else "未连接"
                
                network_interfaces.append({
                    '接口名称': iface,
                    'IP地址': ip_address,
                    'MAC地址': mac_address,
                    '状态': status
                })
            info['网络信息'] = network_interfaces
            info['网络设备与驱动'] = self.get_network_devices_info()
            
            # 显示信息
            info['显示信息'] = {
                '显卡': self.get_gpu_info(),
                '分辨率': self.get_screen_resolution(),
                '颜色深度': self.get_color_depth(),
                '刷新率': self.get_refresh_rate(),
                '驱动信息': self.get_display_driver_info()
            }
            
            # 获取桌面路径
            desktop_path = os.path.join(os.path.expanduser("~"), "Desktop")
            if not os.path.exists(desktop_path):
                desktop_path = os.path.join(os.path.expanduser("~"), "桌面")
            
            # 创建文件名
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"硬件信息_{timestamp}.json"
            filepath = os.path.join(desktop_path, filename)
            
            # 写入JSON文件
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(info, f, ensure_ascii=False, indent=4)
            
            # 显示成功消息
            QMessageBox.information(self, "导出成功", f"硬件信息已成功导出到:\n{filepath}")
            
        except Exception as e:
            QMessageBox.critical(self, "导出失败", f"导出硬件信息时发生错误:\n{str(e)}")
    
    def show_about(self):
        """显示关于对话框"""
        about_text = (
            "GXDE硬件管理器\n\n"
            "版本：2.1.1 \n"
            "描述：\n"
            "这是一个用于查看系统硬件信息的工具，使用pyqt编写。\n\n"
            "感谢所有使用过的开源软件！\n"
            "作者：ocean（zeqi）\n"
            "联系：https://gitee.com/ocean123455/hardware-viewer\n\n"
        )
        
        QMessageBox.about(self, "关于硬件管理器", about_text)
        
    def apply_font_scaling(self):
        """应用字体缩放"""
        default_font = QFont()
        default_font.setPointSizeF(default_font.pointSizeF() * self.scaling_factor)
        self.setFont(default_font)
        
    def init_timer(self):
        """初始化定时器用于实时更新信息"""
        self.timer = QTimer(self)
        self.timer.setInterval(2000)  # 2秒更新一次
        self.timer.timeout.connect(self.update_hardware_info)
        self.timer.start()
        
    def update_hardware_info(self):
        """更新硬件信息"""
        current_index = self.stack.currentIndex()
        
        # 更新CPU信息
        self.update_cpu_info()
        
        # 更新内存信息
        self.update_memory_info()
        
        # 如果在网络页面，更新网络信息
        if current_index == 4:
            self.update_network_info()
            
        # 如果在存储页面，更新磁盘IO信息
        if current_index == 3:
            self.update_disk_io_info()
            
        # 如果在系统信息页面，更新启动时间
        if current_index == 0:
            self.update_uptime()
            
        # 如果在显示页面，更新分辨率信息
        if current_index == 5:
            self.update_display_info()
    
    def add_sidebar_item(self, text, icon_name):
        """添加侧边栏项目"""
        item = QListWidgetItem(text)
        # 图标大小自适应
        icon = QIcon.fromTheme(icon_name, QIcon())
        item.setIcon(icon)
        self.sidebar.addItem(item)
        
    def create_group_box(self, title, widget):
        """创建带标题的分组框"""
        group = QGroupBox(title)
        # 调整标题字体大小
        font = group.font()
        font.setBold(True)
        font.setPointSizeF(font.pointSizeF() * self.scaling_factor)
        group.setFont(font)
        
        layout = QVBoxLayout()
        # 添加内边距
        layout.setContentsMargins(self.scaled(10), self.scaled(10), self.scaled(10), self.scaled(10))
        layout.setSpacing(self.scaled(8))
        layout.addWidget(widget)
        group.setLayout(layout)
        return group
    
    def get_os_version(self):
        """获取操作系统版本信息"""
        try:
            with open('/etc/os-release', 'r') as f:
                for line in f:
                    if line.startswith('PRETTY_NAME='):
                        # 去除引号和换行符
                        return line.split('=')[1].strip().strip('"')
            return "未知系统版本"
        except FileNotFoundError:
            return "无法获取系统版本"
        except Exception as e:
            return f"获取失败: {str(e)}"
            
    def create_system_info_page(self):
        """创建系统信息页面"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(self.scaled(15), self.scaled(15), self.scaled(15), self.scaled(15))
        layout.setSpacing(self.scaled(10))
        
        # 系统概览
        self.sys_info_widget = QWidget()
        sys_layout = QFormLayout()
        sys_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.DontWrapRows)
        sys_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        sys_layout.setHorizontalSpacing(self.scaled(15))
        sys_layout.setVerticalSpacing(self.scaled(8))
        
        # 获取系统信息
        uname = platform.uname()
        
        sys_layout.addRow("操作系统:", QLabel(self.get_os_version()))
        sys_layout.addRow("主机名:", QLabel(uname.node))
        sys_layout.addRow("内核版本:", QLabel(uname.version))
        sys_layout.addRow("系统架构:", QLabel(uname.machine))
        
        # 启动时间标签
        self.uptime_label = QLabel(self.get_uptime())
        sys_layout.addRow("启动时间:", self.uptime_label)
        
        self.sys_info_widget.setLayout(sys_layout)
        layout.addWidget(self.create_group_box("系统概览", self.sys_info_widget))
        
        # 硬件概览
        hw_info = QWidget()
        hw_layout = QFormLayout()
        hw_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.DontWrapRows)
        hw_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        hw_layout.setHorizontalSpacing(self.scaled(15))
        hw_layout.setVerticalSpacing(self.scaled(8))
        
        # 获取硬件信息
        cpu_model = self.get_cpu_model()
        cpu_count = psutil.cpu_count(logical=False) or 0
        logical_cpu = psutil.cpu_count(logical=True) or 0
        mem_total = self.format_size(psutil.virtual_memory().total)
        
        hw_layout.addRow("处理器:", QLabel(f"{cpu_model} ({cpu_count} 核 {logical_cpu} 线程)"))
        hw_layout.addRow("内存总容量:", QLabel(mem_total))
        
        # 获取磁盘总容量
        disk_total = 0
        for part in psutil.disk_partitions():
            if 'cdrom' in part.opts or part.fstype == '':
                continue
            try:
                disk_usage = psutil.disk_usage(part.mountpoint)
                disk_total += disk_usage.total
            except PermissionError:
                continue
        
        hw_layout.addRow("磁盘总容量:", QLabel(self.format_size(disk_total)))
        
        hw_info.setLayout(hw_layout)
        layout.addWidget(self.create_group_box("硬件概览", hw_info))
        
        # 内核模块信息
        kernel_modules = self.get_kernel_modules()
        modules_widget = QWidget()
        modules_layout = QVBoxLayout(modules_widget)
        
        modules_list = QLabel(kernel_modules)
        modules_list.setWordWrap(True)
        modules_layout.addWidget(modules_list)
        
        layout.addWidget(self.create_group_box("加载的核心驱动模块", modules_widget))
        
        layout.addStretch()
        return widget
        
    def create_cpu_page(self):
        """创建CPU信息页面"""
        widget = QScrollArea()
        widget.setWidgetResizable(True)
        
        content = QWidget()
        layout = QVBoxLayout(content)
        layout.setContentsMargins(self.scaled(15), self.scaled(15), self.scaled(15), self.scaled(15))
        layout.setSpacing(self.scaled(10))
        
        # CPU基本信息
        cpu_base = QWidget()
        cpu_base_layout = QFormLayout()
        cpu_base_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.DontWrapRows)
        cpu_base_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        cpu_base_layout.setHorizontalSpacing(self.scaled(15))
        cpu_base_layout.setVerticalSpacing(self.scaled(8))
        
        # 获取CPU详细信息
        cpu_model = self.get_cpu_model()
        cpu_arch = platform.machine()
        cpu_count = psutil.cpu_count(logical=False) or 0
        logical_cpu = psutil.cpu_count(logical=True) or 0
        
        # 处理CPU频率信息
        cpu_freq = psutil.cpu_freq()
        current_freq = f"{cpu_freq.current:.2f} MHz" if cpu_freq and cpu_freq.current else "未知"
        max_freq = f"{cpu_freq.max:.2f} MHz" if cpu_freq and cpu_freq.max else "未知"
        min_freq = f"{cpu_freq.min:.2f} MHz" if cpu_freq and cpu_freq.min else "未知"
        
        # 保存当前频率标签引用以便更新
        self.cpu_current_freq_label = QLabel(current_freq)
        
        cpu_base_layout.addRow("处理器型号:", QLabel(cpu_model))
        cpu_base_layout.addRow("架构:", QLabel(cpu_arch))
        cpu_base_layout.addRow("物理核心:", QLabel(str(cpu_count)))
        cpu_base_layout.addRow("逻辑核心:", QLabel(str(logical_cpu)))
        cpu_base_layout.addRow("当前频率:", self.cpu_current_freq_label)
        cpu_base_layout.addRow("最大频率:", QLabel(max_freq))
        cpu_base_layout.addRow("最小频率:", QLabel(min_freq))
        
        cpu_base.setLayout(cpu_base_layout)
        layout.addWidget(self.create_group_box("基本信息", cpu_base))
        
        # CPU驱动信息
        cpu_drivers = self.get_cpu_driver_info()
        driver_widget = QWidget()
        driver_layout = QFormLayout()
        driver_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.DontWrapRows)
        driver_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        driver_layout.setHorizontalSpacing(self.scaled(15))
        driver_layout.setVerticalSpacing(self.scaled(8))
        
        for key, value in cpu_drivers.items():
            driver_layout.addRow(f"{key}:", QLabel(value))
        
        driver_widget.setLayout(driver_layout)
        layout.addWidget(self.create_group_box("CPU驱动信息", driver_widget))
        
        # CPU使用率 - 修复文字显示+去除黑色描边
        cpu_usage = QWidget()
        cpu_usage_layout = QVBoxLayout()
        cpu_usage_layout.setSpacing(self.scaled(8))
        
        # 总体使用率
        self.cpu_total_bar = QProgressBar()
        self.cpu_total_bar.setFixedHeight(self.scaled(25))
        self.cpu_total_bar.setMinimumWidth(self.scaled(220))  # 增加最小宽度
        self.cpu_total_bar.setAlignment(Qt.AlignmentFlag.AlignCenter)  # 文字居中
        # 修复样式：去除边框+保留内边距，使用与界面协调的浅色边框（可根据需求调整）
        self.cpu_total_bar.setStyleSheet(f"""
            QProgressBar {{
                border: 1px solid #e0e0e0;  /* 浅色边框替代黑色 */
                border-radius: 4px;        /* 可选：添加圆角更美观 */
                padding: 0 {self.scaled(6)}px;
                background-color: #f5f5f5; /* 背景色与界面协调 */
            }}
            QProgressBar::chunk {{
                background-color: #2ca7f8; /* 进度条颜色保持不变 */
                border-radius: 2px;
            }}
        """)
        cpu_percent = psutil.cpu_percent(interval=0.1)
        self.cpu_total_bar.setValue(int(cpu_percent))
        self.cpu_total_bar.setFormat(f"总使用率: {self.cpu_total_bar.value()}%")  # 简化格式
        cpu_usage_layout.addWidget(self.cpu_total_bar)
        
        # 各核心使用率
        label = QLabel("各核心使用率:")
        cpu_usage_layout.addWidget(label)
        
        self.core_usage_layout = QGridLayout()
        self.core_usage_layout.setSpacing(self.scaled(8))
        self.cpu_core_bars = []
        
        # 初始化核心进度条
        for i, percent in enumerate(psutil.cpu_percent(percpu=True, interval=0.1)):
            core_bar = QProgressBar()
            core_bar.setFixedHeight(self.scaled(25))
            core_bar.setMinimumWidth(self.scaled(180))  # 核心进度条最小宽度
            core_bar.setAlignment(Qt.AlignmentFlag.AlignCenter)  # 文字居中
            # 统一样式：去除黑色描边
            core_bar.setStyleSheet(f"""
                QProgressBar {{
                    border: 1px solid #e0e0e0;
                    border-radius: 4px;
                    padding: 0 {self.scaled(6)}px;
                    background-color: #f5f5f5;
                }}
                QProgressBar::chunk {{
                    background-color: #2ca7f8;
                    border-radius: 2px;
                }}
            """)
            core_bar.setValue(int(percent))
            core_bar.setFormat(f"核{i}: {core_bar.value()}%")  # 简化格式（核X代替核心X）
            self.core_usage_layout.addWidget(core_bar, i // 2, i % 2)
            self.cpu_core_bars.append(core_bar)
        
        cpu_usage_layout.addLayout(self.core_usage_layout)
        cpu_usage.setLayout(cpu_usage_layout)
        layout.addWidget(self.create_group_box("CPU使用率", cpu_usage))
        
        layout.addStretch()
        widget.setWidget(content)
        return widget
        
    def create_memory_page(self):
        """创建内存信息页面"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(self.scaled(15), self.scaled(15), self.scaled(15), self.scaled(15))
        layout.setSpacing(self.scaled(10))
        
        # 内存使用情况
        mem_info = QWidget()
        mem_layout = QVBoxLayout()
        mem_layout.setSpacing(self.scaled(8))
        
        # 总内存信息 - 修复文字显示+去除黑色描边
        mem = psutil.virtual_memory()
        
        self.mem_total_bar = QProgressBar()
        self.mem_total_bar.setFixedHeight(self.scaled(25))
        self.mem_total_bar.setMinimumWidth(self.scaled(250))  # 增加最小宽度
        self.mem_total_bar.setAlignment(Qt.AlignmentFlag.AlignCenter)  # 文字居中
        # 统一样式
        self.mem_total_bar.setStyleSheet(f"""
            QProgressBar {{
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                padding: 0 {self.scaled(6)}px;
                background-color: #f5f5f5;
            }}
            QProgressBar::chunk {{
                background-color: #4CAF50; /* 内存进度条用绿色区分 */
                border-radius: 2px;
            }}
        """)
        self.mem_total_bar.setValue(int(mem.percent))
        # 简化格式，保留关键信息
        self.mem_total_bar.setFormat(f"内存使用率: {mem.percent:.1f}% ({self.format_size(mem.used)}/{self.format_size(mem.total)})")
        mem_layout.addWidget(self.mem_total_bar)
        
        # 详细内存信息
        self.mem_details = QWidget()
        mem_details_layout = QFormLayout()
        mem_details_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.DontWrapRows)
        mem_details_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        mem_details_layout.setHorizontalSpacing(self.scaled(15))
        mem_details_layout.setVerticalSpacing(self.scaled(8))
        
        self.mem_used_label = QLabel(self.format_size(mem.used))
        self.mem_free_label = QLabel(self.format_size(mem.free))
        self.mem_available_label = QLabel(self.format_size(mem.available))
        self.mem_cache_label = QLabel(self.format_size(mem.total - mem.used - mem.free))
        
        mem_details_layout.addRow("总内存:", QLabel(self.format_size(mem.total)))
        mem_details_layout.addRow("已使用:", self.mem_used_label)
        mem_details_layout.addRow("空闲:", self.mem_free_label)
        mem_details_layout.addRow("可用:", self.mem_available_label)
        mem_details_layout.addRow("缓存:", self.mem_cache_label)
        
        self.mem_details.setLayout(mem_details_layout)
        mem_layout.addWidget(self.mem_details)
        
        mem_info.setLayout(mem_layout)
        layout.addWidget(self.create_group_box("内存信息", mem_info))
        
        # 内存硬件和驱动信息
        mem_hw_info = self.get_memory_hardware_info()
        mem_driver_widget = QWidget()
        mem_driver_layout = QFormLayout()
        mem_driver_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.DontWrapRows)
        mem_driver_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        mem_driver_layout.setHorizontalSpacing(self.scaled(15))
        mem_driver_layout.setVerticalSpacing(self.scaled(8))
        
        for key, value in mem_hw_info.items():
            mem_driver_layout.addRow(f"{key}:", QLabel(value))
        
        mem_driver_widget.setLayout(mem_driver_layout)
        layout.addWidget(self.create_group_box("内存硬件与驱动", mem_driver_widget))
        
        # 交换分区信息 - 修复文字显示+去除黑色描边
        swap_info = QWidget()
        swap_layout = QVBoxLayout()
        swap_layout.setSpacing(self.scaled(8))
        
        swap = psutil.swap_memory()
        
        self.swap_bar = QProgressBar()
        self.swap_bar.setFixedHeight(self.scaled(25))
        self.swap_bar.setMinimumWidth(self.scaled(250))  # 增加最小宽度
        self.swap_bar.setAlignment(Qt.AlignmentFlag.AlignCenter)  # 文字居中
        # 统一样式，用橙色区分交换分区
        self.swap_bar.setStyleSheet(f"""
            QProgressBar {{
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                padding: 0 {self.scaled(6)}px;
                background-color: #f5f5f5;
            }}
            QProgressBar::chunk {{
                background-color: #FF9800; /* 交换分区用橙色区分 */
                border-radius: 2px;
            }}
        """)
        self.swap_bar.setValue(int(swap.percent))
        # 简化格式
        self.swap_bar.setFormat(f"交换分区使用率: {swap.percent:.1f}% ({self.format_size(swap.used)}/{self.format_size(swap.total)})")
        swap_layout.addWidget(self.swap_bar)
        
        # 交换分区详细信息
        self.swap_details = QWidget()
        swap_details_layout = QFormLayout()
        swap_details_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.DontWrapRows)
        swap_details_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        swap_details_layout.setHorizontalSpacing(self.scaled(15))
        swap_details_layout.setVerticalSpacing(self.scaled(8))
        
        self.swap_used_label = QLabel(self.format_size(swap.used))
        self.swap_free_label = QLabel(self.format_size(swap.free))
        
        swap_details_layout.addRow("总交换分区:", QLabel(self.format_size(swap.total)))
        swap_details_layout.addRow("已使用:", self.swap_used_label)
        swap_details_layout.addRow("空闲:", self.swap_free_label)
        
        self.swap_details.setLayout(swap_details_layout)
        swap_layout.addWidget(self.swap_details)
        
        swap_info.setLayout(swap_layout)
        layout.addWidget(self.create_group_box("交换分区信息", swap_info))
        
        layout.addStretch()
        return widget
        
    def create_storage_page(self):
        """创建存储信息页面"""
        widget = QScrollArea()
        widget.setWidgetResizable(True)
        
        content = QWidget()
        layout = QVBoxLayout(content)
        layout.setContentsMargins(self.scaled(15), self.scaled(15), self.scaled(15), self.scaled(15))
        layout.setSpacing(self.scaled(10))
        
        # 磁盘分区信息
        disk_table = QTableWidget()
        disk_table.setColumnCount(5)
        disk_table.setHorizontalHeaderLabels(["设备", "挂载点", "文件系统", "总容量", "可用空间"])
        disk_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        # 设置表格字体
        font = disk_table.font()
        font.setPointSizeF(font.pointSizeF() * self.scaling_factor)
        disk_table.setFont(font)
        # 设置表头高度
        header = disk_table.horizontalHeader()
        header.setMinimumHeight(self.scaled(25))
        
        # 获取磁盘信息
        disks = psutil.disk_partitions()
        disk_table.setRowCount(len(disks))
        
        for row, part in enumerate(disks):
            # 设置行高
            disk_table.setRowHeight(row, self.scaled(25))
            
            if 'cdrom' in part.opts or part.fstype == '':
                disk_table.setItem(row, 0, QTableWidgetItem(part.device))
                disk_table.setItem(row, 1, QTableWidgetItem(part.mountpoint))
                disk_table.setItem(row, 2, QTableWidgetItem(part.fstype))
                disk_table.setItem(row, 3, QTableWidgetItem("N/A"))
                disk_table.setItem(row, 4, QTableWidgetItem("N/A"))
                continue
                
            try:
                disk_usage = psutil.disk_usage(part.mountpoint)
            except PermissionError:
                disk_table.setItem(row, 0, QTableWidgetItem(part.device))
                disk_table.setItem(row, 1, QTableWidgetItem(part.mountpoint))
                disk_table.setItem(row, 2, QTableWidgetItem(part.fstype))
                disk_table.setItem(row, 3, QTableWidgetItem("无权限"))
                disk_table.setItem(row, 4, QTableWidgetItem("无权限"))
                continue
                
            disk_table.setItem(row, 0, QTableWidgetItem(part.device))
            disk_table.setItem(row, 1, QTableWidgetItem(part.mountpoint))
            disk_table.setItem(row, 2, QTableWidgetItem(part.fstype))
            disk_table.setItem(row, 3, QTableWidgetItem(self.format_size(disk_usage.total)))
            disk_table.setItem(row, 4, QTableWidgetItem(self.format_size(disk_usage.free)))
        
        disk_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.create_group_box("磁盘分区", disk_table))
        
        # 存储设备和驱动信息
        storage_devices = self.get_storage_devices_info()
        storage_driver_widget = QWidget()
        storage_driver_layout = QVBoxLayout(storage_driver_widget)
        
        storage_table = QTableWidget()
        storage_table.setColumnCount(3)
        storage_table.setHorizontalHeaderLabels(["设备名称", "型号", "驱动模块"])
        storage_table.setRowCount(len(storage_devices))
        storage_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        
        for row, device in enumerate(storage_devices):
            storage_table.setRowHeight(row, self.scaled(25))
            storage_table.setItem(row, 0, QTableWidgetItem(device.get('name', '未知')))
            storage_table.setItem(row, 1, QTableWidgetItem(device.get('model', '未知')))
            storage_table.setItem(row, 2, QTableWidgetItem(device.get('driver', '未知')))
        
        storage_table.horizontalHeader().setStretchLastSection(True)
        storage_driver_layout.addWidget(storage_table)
        
        layout.addWidget(self.create_group_box("存储设备与驱动", storage_driver_widget))
        
        # 磁盘IO信息
        self.disk_io_widget = QWidget()
        io_layout = QFormLayout()
        io_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.DontWrapRows)
        io_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        io_layout.setHorizontalSpacing(self.scaled(15))
        io_layout.setVerticalSpacing(self.scaled(8))
        
        disk_io = psutil.disk_io_counters()
        self.disk_io_labels['read_count'] = QLabel(str(disk_io.read_count))
        self.disk_io_labels['write_count'] = QLabel(str(disk_io.write_count))
        self.disk_io_labels['read_bytes'] = QLabel(self.format_size(disk_io.read_bytes))
        self.disk_io_labels['write_bytes'] = QLabel(self.format_size(disk_io.write_bytes))
        
        io_layout.addRow("读取次数:", self.disk_io_labels['read_count'])
        io_layout.addRow("写入次数:", self.disk_io_labels['write_count'])
        io_layout.addRow("读取字节:", self.disk_io_labels['read_bytes'])
        io_layout.addRow("写入字节:", self.disk_io_labels['write_bytes'])
        
        self.disk_io_widget.setLayout(io_layout)
        layout.addWidget(self.create_group_box("磁盘IO统计", self.disk_io_widget))
        
        layout.addStretch()
        widget.setWidget(content)
        return widget
        
    def create_network_page(self):
        """创建网络信息页面"""
        widget = QScrollArea()
        widget.setWidgetResizable(True)
        
        content = QWidget()
        layout = QVBoxLayout(content)
        layout.setContentsMargins(self.scaled(15), self.scaled(15), self.scaled(15), self.scaled(15))
        layout.setSpacing(self.scaled(10))
        
        # 网络接口信息
        net_table = QTableWidget()
        net_table.setColumnCount(4)
        net_table.setHorizontalHeaderLabels(["接口名称", "IP地址", "MAC地址", "状态"])
        net_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        # 设置表格字体
        font = net_table.font()
        font.setPointSizeF(font.pointSizeF() * self.scaling_factor)
        net_table.setFont(font)
        # 设置表头高度
        header = net_table.horizontalHeader()
        header.setMinimumHeight(self.scaled(25))
        
        # 获取网络接口信息
        net_if_addrs = psutil.net_if_addrs()
        net_if_stats = psutil.net_if_stats()
        
        net_table.setRowCount(len(net_if_addrs))
        
        for row, iface in enumerate(net_if_addrs):
            # 设置行高
            net_table.setRowHeight(row, self.scaled(25))
            
            # 获取IP地址
            ip_address = "无"
            for addr in net_if_addrs[iface]:
                if addr.family == socket.AF_INET:
                    ip_address = addr.address
                    break
                    
            # 获取MAC地址
            mac_address = "无"
            for addr in net_if_addrs[iface]:
                if hasattr(addr, 'family') and addr.family == psutil.AF_LINK:
                    mac_address = addr.address
                    break
                    
            # 获取状态
            status = "未知"
            if iface in net_if_stats:
                status = "已连接" if net_if_stats[iface].isup else "未连接"
            
            net_table.setItem(row, 0, QTableWidgetItem(iface))
            net_table.setItem(row, 1, QTableWidgetItem(ip_address))
            net_table.setItem(row, 2, QTableWidgetItem(mac_address))
            net_table.setItem(row, 3, QTableWidgetItem(status))
        
        net_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.create_group_box("网络接口", net_table))
        
        # 网络设备和驱动信息
        net_devices = self.get_network_devices_info()
        net_driver_widget = QWidget()
        net_driver_layout = QVBoxLayout(net_driver_widget)
        
        net_driver_table = QTableWidget()
        net_driver_table.setColumnCount(3)
        net_driver_table.setHorizontalHeaderLabels(["接口名称", "设备型号", "驱动模块"])
        net_driver_table.setRowCount(len(net_devices))
        net_driver_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        
        for row, device in enumerate(net_devices):
            net_driver_table.setRowHeight(row, self.scaled(25))
            net_driver_table.setItem(row, 0, QTableWidgetItem(device.get('interface', '未知')))
            net_driver_table.setItem(row, 1, QTableWidgetItem(device.get('model', '未知')))
            net_driver_table.setItem(row, 2, QTableWidgetItem(device.get('driver', '未知')))
        
        net_driver_table.horizontalHeader().setStretchLastSection(True)
        net_driver_layout.addWidget(net_driver_table)
        
        layout.addWidget(self.create_group_box("网络设备与驱动", net_driver_widget))
        
        # 网络流量信息
        self.net_io_widget = QWidget()
        net_io_layout = QFormLayout()
        net_io_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.DontWrapRows)
        net_io_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        net_io_layout.setHorizontalSpacing(self.scaled(15))
        net_io_layout.setVerticalSpacing(self.scaled(8))
        
        net_counter = psutil.net_io_counters()
        self.net_io_labels['bytes_recv'] = QLabel(self.format_size(net_counter.bytes_recv))
        self.net_io_labels['bytes_sent'] = QLabel(self.format_size(net_counter.bytes_sent))
        self.net_io_labels['packets_recv'] = QLabel(str(net_counter.packets_recv))
        self.net_io_labels['packets_sent'] = QLabel(str(net_counter.packets_sent))
        self.net_io_labels['errin'] = QLabel(str(net_counter.errin))
        self.net_io_labels['errout'] = QLabel(str(net_counter.errout))
        
        net_io_layout.addRow("接收字节:", self.net_io_labels['bytes_recv'])
        net_io_layout.addRow("发送字节:", self.net_io_labels['bytes_sent'])
        net_io_layout.addRow("接收包数:", self.net_io_labels['packets_recv'])
        net_io_layout.addRow("发送包数:", self.net_io_labels['packets_sent'])
        net_io_layout.addRow("接收错误:", self.net_io_labels['errin'])
        net_io_layout.addRow("发送错误:", self.net_io_labels['errout'])
        
        self.net_io_widget.setLayout(net_io_layout)
        layout.addWidget(self.create_group_box("网络流量统计", self.net_io_widget))
        
        layout.addStretch()
        widget.setWidget(content)
        return widget
        
    def create_display_page(self):
        """创建显示信息页面"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(self.scaled(15), self.scaled(15), self.scaled(15), self.scaled(15))
        layout.setSpacing(self.scaled(10))
        
        # 显示设备信息
        display_info = QWidget()
        display_layout = QFormLayout()
        display_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.DontWrapRows)
        display_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        display_layout.setHorizontalSpacing(self.scaled(15))
        display_layout.setVerticalSpacing(self.scaled(8))
        
        gpu_info = self.get_gpu_info()
        resolution = self.get_screen_resolution()
        color_depth = self.get_color_depth()
        refresh_rate = self.get_refresh_rate()
        
        display_layout.addRow("显卡:", QLabel(gpu_info))
        display_layout.addRow("分辨率:", QLabel(resolution))
        display_layout.addRow("颜色深度:", QLabel(color_depth))
        display_layout.addRow("刷新率:", QLabel(refresh_rate))
        
        display_info.setLayout(display_layout)
        layout.addWidget(self.create_group_box("显示设备信息", display_info))
        
        # 显示驱动信息
        display_drivers = self.get_display_driver_info()
        driver_widget = QWidget()
        driver_layout = QFormLayout()
        driver_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.DontWrapRows)
        driver_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        driver_layout.setHorizontalSpacing(self.scaled(15))
        driver_layout.setVerticalSpacing(self.scaled(8))
        
        for key, value in display_drivers.items():
            driver_layout.addRow(f"{key}:", QLabel(value))
        
        driver_widget.setLayout(driver_layout)
        layout.addWidget(self.create_group_box("显示驱动信息", driver_widget))
        
        layout.addStretch()
        return widget
        
    def create_sound_page(self):
        """创建声音信息页面"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(self.scaled(15), self.scaled(15), self.scaled(15), self.scaled(15))
        layout.setSpacing(self.scaled(10))
        
        # 声音设备信息
        sound_devices = self.get_sound_devices_info()
        sound_widget = QWidget()
        sound_layout = QVBoxLayout(sound_widget)
        
        sound_table = QTableWidget()
        sound_table.setColumnCount(3)
        sound_table.setHorizontalHeaderLabels(["设备名称", "类型", "驱动模块"])
        sound_table.setRowCount(len(sound_devices))
        sound_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        
        for row, device in enumerate(sound_devices):
            sound_table.setRowHeight(row, self.scaled(25))
            sound_table.setItem(row, 0, QTableWidgetItem(device.get('name', '未知')))
            sound_table.setItem(row, 1, QTableWidgetItem(device.get('type', '未知')))
            sound_table.setItem(row, 2, QTableWidgetItem(device.get('driver', '未知')))
        
        sound_table.horizontalHeader().setStretchLastSection(True)
        sound_layout.addWidget(sound_table)
        
        layout.addWidget(self.create_group_box("声音设备与驱动", sound_widget))
        
        layout.addStretch()
        return widget
        
    def create_input_page(self):
        """创建输入设备页面"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(self.scaled(15), self.scaled(15), self.scaled(15), self.scaled(15))
        layout.setSpacing(self.scaled(10))
        
        # 输入设备信息
        input_devices = self.get_input_devices_info()
        input_widget = QWidget()
        input_layout = QVBoxLayout(input_widget)
        
        input_table = QTableWidget()
        input_table.setColumnCount(3)
        input_table.setHorizontalHeaderLabels(["设备名称", "类型", "驱动模块"])
        input_table.setRowCount(len(input_devices))
        input_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        
        for row, device in enumerate(input_devices):
            input_table.setRowHeight(row, self.scaled(25))
            input_table.setItem(row, 0, QTableWidgetItem(device.get('name', '未知')))
            input_table.setItem(row, 1, QTableWidgetItem(device.get('type', '未知')))
            input_table.setItem(row, 2, QTableWidgetItem(device.get('driver', '未知')))
        
        input_table.horizontalHeader().setStretchLastSection(True)
        input_layout.addWidget(input_table)
        
        layout.addWidget(self.create_group_box("输入设备与驱动", input_widget))
        
        layout.addStretch()
        return widget
    
    # 硬件信息获取方法
    def get_uptime(self):
        """获取系统启动时间"""
        boot_time = datetime.fromtimestamp(psutil.boot_time())
        now = datetime.now()
        delta = now - boot_time
        
        days = delta.days
        hours, remainder = divmod(delta.seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        
        return f"{days}天 {hours}时 {minutes}分 {seconds}秒"
        
    def format_size(self, size_bytes):
        """格式化字节大小为人类可读形式"""
        units = ['B', 'KB', 'MB', 'GB', 'TB']
        size = size_bytes
        unit_index = 0
        
        while size >= 1024 and unit_index < len(units) - 1:
            size /= 1024
            unit_index += 1
            
        return f"{size:.2f} {units[unit_index]}"
        
    def get_cpu_model(self):
        """获取CPU型号"""
        try:
            with open('/proc/cpuinfo', 'r') as f:
                for line in f:
                    if line.strip().startswith('model name'):
                        return line.split(':')[1].strip()
            return "未知"
        except:
            return "未知"
            
    def get_kernel_modules(self):
        """获取加载的内核模块"""
        try:
            result = subprocess.run(['lsmod'], capture_output=True, text=True)
            modules = result.stdout.splitlines()[1:10]  # 只显示前10个
            return "\n".join([line.split()[0] for line in modules])
        except:
            return "无法获取内核模块信息"
            
    def update_cpu_info(self):
        """更新CPU信息"""
        # 更新总体使用率
        if self.cpu_total_bar:
            cpu_percent = psutil.cpu_percent(interval=0.1)
            self.cpu_total_bar.setValue(int(cpu_percent))
            self.cpu_total_bar.setFormat(f"总使用率: {self.cpu_total_bar.value()}%")  # 同步简化格式
        
        # 更新各核心使用率
        if self.cpu_core_bars:
            core_percents = psutil.cpu_percent(percpu=True, interval=0.1)
            for i, percent in enumerate(core_percents):
                if i < len(self.cpu_core_bars):
                    self.cpu_core_bars[i].setValue(int(percent))
                    self.cpu_core_bars[i].setFormat(f"核{i}: {self.cpu_core_bars[i].value()}%")  # 同步简化格式
        
        # 更新当前频率
        if hasattr(self, 'cpu_current_freq_label'):
            cpu_freq = psutil.cpu_freq()
            current_freq = f"{cpu_freq.current:.2f} MHz" if cpu_freq and cpu_freq.current else "未知"
            self.cpu_current_freq_label.setText(current_freq)
            
    def update_memory_info(self):
        """更新内存信息"""
        # 更新内存使用情况
        if self.mem_total_bar:
            mem = psutil.virtual_memory()
            self.mem_total_bar.setValue(int(mem.percent))
            # 同步简化格式
            self.mem_total_bar.setFormat(f"内存使用率: {mem.percent:.1f}% ({self.format_size(mem.used)}/{self.format_size(mem.total)})")
            
            if hasattr(self, 'mem_used_label'):
                self.mem_used_label.setText(self.format_size(mem.used))
                self.mem_free_label.setText(self.format_size(mem.free))
                self.mem_available_label.setText(self.format_size(mem.available))
                self.mem_cache_label.setText(self.format_size(mem.total - mem.used - mem.free))
        
        # 更新交换分区信息
        if self.swap_bar:
            swap = psutil.swap_memory()
            self.swap_bar.setValue(int(swap.percent))
            # 同步简化格式
            self.swap_bar.setFormat(f"交换分区使用率: {swap.percent:.1f}% ({self.format_size(swap.used)}/{self.format_size(swap.total)})")
            
            if hasattr(self, 'swap_used_label'):
                self.swap_used_label.setText(self.format_size(swap.used))
                self.swap_free_label.setText(self.format_size(swap.free))
                
    def update_network_info(self):
        """更新网络信息"""
        if self.net_io_labels:
            net_counter = psutil.net_io_counters()
            self.net_io_labels['bytes_recv'].setText(self.format_size(net_counter.bytes_recv))
            self.net_io_labels['bytes_sent'].setText(self.format_size(net_counter.bytes_sent))
            self.net_io_labels['packets_recv'].setText(str(net_counter.packets_recv))
            self.net_io_labels['packets_sent'].setText(str(net_counter.packets_sent))
            self.net_io_labels['errin'].setText(str(net_counter.errin))
            self.net_io_labels['errout'].setText(str(net_counter.errout))
            
    def update_disk_io_info(self):
        """更新磁盘IO信息"""
        if self.disk_io_labels:
            disk_io = psutil.disk_io_counters()
            self.disk_io_labels['read_count'].setText(str(disk_io.read_count))
            self.disk_io_labels['write_count'].setText(str(disk_io.write_count))
            self.disk_io_labels['read_bytes'].setText(self.format_size(disk_io.read_bytes))
            self.disk_io_labels['write_bytes'].setText(self.format_size(disk_io.write_bytes))
            
    def update_uptime(self):
        """更新系统启动时间"""
        if hasattr(self, 'uptime_label'):
            self.uptime_label.setText(self.get_uptime())
            
    def update_display_info(self):
        """更新显示信息"""
        # 可以在这里添加显示信息的实时更新逻辑
        pass
        
    def get_gpu_info(self):
        """获取GPU信息"""
        try:
            result = subprocess.run(['lspci'], capture_output=True, text=True)
            gpus = []
            for line in result.stdout.splitlines():
                if 'VGA' in line or '3D' in line or 'Display' in line:
                    gpus.append(line.split(': ', 2)[-1])
            return '\n'.join(gpus) if gpus else "未知"
        except:
            return "无法获取GPU信息"
            
    def get_screen_resolution(self):
        """获取屏幕分辨率"""
        try:
            screen = QApplication.primaryScreen()
            geometry = screen.geometry()
            return f"{geometry.width()} x {geometry.height()}"
        except:
            return "未知"
            
    def get_color_depth(self):
        """获取颜色深度"""
        try:
            screen = QApplication.primaryScreen()
            depth = screen.depth()
            return f"{depth} 位"
        except:
            return "未知"
            
    def get_refresh_rate(self):
        """获取刷新率"""
        try:
            screen = QApplication.primaryScreen()
            refresh_rate = screen.refreshRate()
            return f"{refresh_rate} Hz" if refresh_rate > 0 else "未知"
        except:
            return "未知"
            
    # 驱动信息获取方法 - 核心修复部分
    def get_cpu_driver_info(self):
        """获取CPU驱动信息"""
        try:
            drivers = {}
            
            # 获取CPU微码信息
            if os.path.exists('/proc/cpuinfo'):
                with open('/proc/cpuinfo', 'r') as f:
                    for line in f:
                        if line.strip().startswith('microcode'):
                            drivers['微码版本'] = line.split(':')[1].strip()
                            break
            
            # 获取CPU频率调节驱动
            cpufreq_drivers = []
            if os.path.exists('/sys/devices/system/cpu/cpufreq/'):
                for driver in os.listdir('/sys/devices/system/cpu/cpufreq/'):
                    if driver.startswith('policy'):
                        try:
                            with open(f'/sys/devices/system/cpu/cpufreq/{driver}/scaling_driver', 'r') as f:
                                cpufreq_drivers.append(f.read().strip())
                        except:
                            continue
            if cpufreq_drivers:
                drivers['频率调节驱动'] = ', '.join(list(set(cpufreq_drivers)))
            
            # 获取CPU电源管理驱动
            if os.path.exists('/sys/devices/system/cpu/cpuidle/current_driver'):
                with open('/sys/devices/system/cpu/cpuidle/current_driver', 'r') as f:
                    drivers['电源管理驱动'] = f.read().strip()
            
            if not drivers:
                drivers['状态'] = '未检测到特定驱动信息'
                
            return drivers
        except Exception as e:
            return {'错误': f'无法获取CPU驱动信息: {str(e)}'}
            
    def get_memory_hardware_info(self):
        """获取内存硬件与驱动信息"""
        try:
            mem_info = {}
            
            # 获取内存总量（已在前面显示，这里补充其他信息）
            mem = psutil.virtual_memory()
            mem_info['总容量'] = self.format_size(mem.total)
            
            # 获取内存控制器信息
            result = subprocess.run(['lspci | grep -i memory'], shell=True, capture_output=True, text=True)
            if result.stdout:
                mem_info['内存控制器'] = result.stdout.splitlines()[0].split(': ', 2)[-1]
            
            # 获取内存驱动/控制器模块
            result = subprocess.run(['lsmod | grep -i "ddr\|memory\|ram"'], shell=True, capture_output=True, text=True)
            if result.stdout:
                modules = [line.split()[0] for line in result.stdout.splitlines()]
                mem_info['相关驱动模块'] = ', '.join(modules)
            
            # 检查内存插槽信息
            if os.path.exists('/proc/meminfo'):
                with open('/proc/meminfo', 'r') as f:
                    for line in f:
                        if line.startswith('MemTotal:'):
                            continue  # 已显示
                        if line.startswith('MemFree:'):
                            continue  # 已显示
                        if line.startswith('MemAvailable:'):
                            continue  # 已显示
                        if line.startswith('HugePages_Total:'):
                            mem_info['大页总数'] = line.split()[1]
            
            if not mem_info:
                mem_info['状态'] = '未检测到内存硬件信息'
                
            return mem_info
        except Exception as e:
            return {'错误': f'无法获取内存信息: {str(e)}'}
            
    def get_storage_devices_info(self):
        """获取存储设备与驱动信息"""
        try:
            devices = []
            
            # 通过lsblk获取块设备信息
            result = subprocess.run(['lsblk -o NAME,TYPE,MODEL,SIZE -n'], shell=True, capture_output=True, text=True)
            for line in result.stdout.splitlines():
                parts = line.strip().split()
                if len(parts) >= 3 and parts[1] in ['disk', 'ssd', 'hdd']:
                    device_name = parts[0]
                    device_type = parts[1]
                    device_model = ' '.join(parts[2:-1]) if len(parts) > 3 else parts[2]
                    
                    # 获取驱动信息
                    driver = "未知"
                    if os.path.exists(f'/sys/block/{device_name}/device/driver'):
                        try:
                            driver_path = os.path.realpath(f'/sys/block/{device_name}/device/driver')
                            driver = os.path.basename(driver_path)
                        except:
                            pass
                    
                    devices.append({
                        'name': f'/dev/{device_name}',
                        'model': f'{device_model} ({device_type})',
                        'driver': driver
                    })
            
            if not devices:
                # 尝试通过lspci获取存储控制器信息
                result = subprocess.run(['lspci | grep -i "storage\|sata\|scsi"'], shell=True, capture_output=True, text=True)
                for line in result.stdout.splitlines():
                    parts = line.split(': ', 2)
                    if len(parts) >= 3:
                        devices.append({
                            'name': f'控制器 {parts[0].split()[0]}',
                            'model': parts[2],
                            'driver': '未知（需要进一步查询）'
                        })
            
            return devices
        except Exception as e:
            return [{'name': '错误', 'model': '', 'driver': f'无法获取存储设备信息: {str(e)}'}]
            
    def get_network_devices_info(self):
        """获取网络设备与驱动信息"""
        try:
            devices = []
            
            # 获取网络接口列表
            interfaces = psutil.net_if_addrs().keys()
            
            for iface in interfaces:
                # 跳过回环接口
                if iface == 'lo':
                    continue
                
                # 获取MAC地址
                mac = "未知"
                for addr in psutil.net_if_addrs()[iface]:
                    if hasattr(addr, 'family') and addr.family == psutil.AF_LINK:
                        mac = addr.address
                        break
                
                # 获取驱动信息
                driver = "未知"
                if os.path.exists(f'/sys/class/net/{iface}/device/driver'):
                    try:
                        driver_path = os.path.realpath(f'/sys/class/net/{iface}/device/driver')
                        driver = os.path.basename(driver_path)
                    except:
                        pass
                
                # 获取设备型号
                model = "未知"
                if os.path.exists(f'/sys/class/net/{iface}/device/product_name'):
                    try:
                        with open(f'/sys/class/net/{iface}/device/product_name', 'r') as f:
                            model = f.read().strip()
                    except:
                        pass
                
                devices.append({
                    'interface': iface,
                    'model': f'{model} ({mac})',
                    'driver': driver
                })
            
            if not devices:
                # 尝试通过lspci获取网络控制器信息
                result = subprocess.run(['lspci | grep -i "ethernet\|wireless\|network"'], shell=True, capture_output=True, text=True)
                for line in result.stdout.splitlines():
                    parts = line.split(': ', 2)
                    if len(parts) >= 3:
                        devices.append({
                            'interface': f'控制器 {parts[0].split()[0]}',
                            'model': parts[2],
                            'driver': '未知（需要进一步查询）'
                        })
            
            return devices
        except Exception as e:
            return [{'interface': '错误', 'model': '', 'driver': f'无法获取网络设备信息: {str(e)}'}]
            
    def get_display_driver_info(self):
        """获取显示驱动信息"""
        try:
            drivers = {}
            
            # 通过lspci获取显卡信息
            result = subprocess.run(['lspci | grep -i "vga\|3d\|display"'], shell=True, capture_output=True, text=True)
            gpu_lines = result.stdout.splitlines()
            
            # 通过glxinfo获取OpenGL驱动信息（需要mesa-utils包）
            try:
                result = subprocess.run(['glxinfo | grep "OpenGL vendor string\|OpenGL renderer string"'], 
                                       shell=True, capture_output=True, text=True)
                for line in result.stdout.splitlines():
                    if 'vendor' in line:
                        drivers['OpenGL供应商'] = line.split(': ')[1]
                    if 'renderer' in line:
                        drivers['OpenGL渲染器'] = line.split(': ')[1]
            except:
                pass
            
            # 通过modinfo获取显卡驱动模块信息
            for i, line in enumerate(gpu_lines):
                parts = line.split()
                if len(parts) >= 1:
                    pci_id = parts[0]
                    try:
                        # 获取驱动模块
                        result = subprocess.run(['lspci -k -s ' + pci_id], shell=True, capture_output=True, text=True)
                        for l in result.stdout.splitlines():
                            if 'Kernel driver in use:' in l:
                                driver_name = l.split(': ')[1]
                                drivers[f'显卡{i+1}驱动'] = driver_name
                                
                                # 获取驱动版本
                                try:
                                    result = subprocess.run(['modinfo ' + driver_name + ' | grep version'], 
                                                           shell=True, capture_output=True, text=True)
                                    if result.stdout:
                                        version = result.stdout.split(': ')[1].strip()
                                        drivers[f'显卡{i+1}驱动版本'] = version
                                except:
                                    pass
                    except:
                        pass
            
            if not drivers:
                drivers['状态'] = '未检测到显示驱动信息'
                
            return drivers
        except Exception as e:
            return {'错误': f'无法获取显示驱动信息: {str(e)}'}
            
    def get_sound_devices_info(self):
        """获取声音设备与驱动信息"""
        try:
            devices = []
            
            # 通过lspci获取音频控制器
            result = subprocess.run(['lspci | grep -i "audio"'], shell=True, capture_output=True, text=True)
            for line in result.stdout.splitlines():
                parts = line.split(': ', 2)
                if len(parts) >= 3:
                    pci_id = parts[0].split()[0]
                    model = parts[2]
                    
                    # 获取驱动信息
                    driver = "未知"
                    try:
                        result = subprocess.run(['lspci -k -s ' + pci_id], shell=True, capture_output=True, text=True)
                        for l in result.stdout.splitlines():
                            if 'Kernel driver in use:' in l:
                                driver = l.split(': ')[1]
                                break
                    except:
                        pass
                    
                    devices.append({
                        'name': f'音频控制器 {pci_id}',
                        'type': '内置音频',
                        'driver': driver
                    })
            
            # 通过aplay获取音频设备（需要alsa-utils包）
            try:
                result = subprocess.run(['aplay -l'], shell=True, capture_output=True, text=True)
                for line in result.stdout.splitlines():
                    if 'card' in line and ':' in line:
                        parts = line.strip().split(': ')
                        if len(parts) >= 2:
                            devices.append({
                                'name': parts[1],
                                'type': '音频播放设备',
                                'driver': 'ALSA'
                            })
            except:
                pass
            
            if not devices:
                devices.append({'name': '未知', 'type': '音频设备', 'driver': '未检测到声音设备'})
                
            return devices
        except Exception as e:
            return [{'name': '错误', 'type': '', 'driver': f'无法获取声音设备信息: {str(e)}'}]
            
    def get_input_devices_info(self):
        """获取输入设备与驱动信息"""
        try:
            devices = []
            
            # 检查/dev/input目录下的设备
            if os.path.exists('/dev/input'):
                for device in os.listdir('/dev/input'):
                    if device.startswith('event'):
                        try:
                            # 获取设备名称
                            with open(f'/sys/class/input/{device}/device/name', 'r') as f:
                                name = f.read().strip()
                            
                            # 获取设备类型
                            dev_type = "未知"
                            if 'keyboard' in name.lower():
                                dev_type = '键盘'
                            elif 'mouse' in name.lower():
                                dev_type = '鼠标'
                            elif 'touchpad' in name.lower():
                                dev_type = '触摸板'
                            elif 'touchscreen' in name.lower():
                                dev_type = '触摸屏'
                            elif 'joystick' in name.lower() or 'gamepad' in name.lower():
                                dev_type = '游戏控制器'
                            
                            # 获取驱动信息
                            driver = "未知"
                            if os.path.exists(f'/sys/class/input/{device}/device/driver'):
                                try:
                                    driver_path = os.path.realpath(f'/sys/class/input/{device}/device/driver')
                                    driver = os.path.basename(driver_path)
                                except:
                                    pass
                            
                            devices.append({
                                'name': name,
                                'type': dev_type,
                                'driver': driver
                            })
                        except:
                            continue
            
            # 去重
            unique_devices = []
            seen = set()
            for dev in devices:
                key = (dev['name'], dev['type'])
                if key not in seen:
                    seen.add(key)
                    unique_devices.append(dev)
            
            if not unique_devices:
                unique_devices.append({'name': '未知', 'type': '输入设备', 'driver': '未检测到输入设备'})
                
            return unique_devices
        except Exception as e:
            return [{'name': '错误', 'type': '', 'driver': f'无法获取输入设备信息: {str(e)}'}]

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = HardwareManager()
    window.show()
    sys.exit(app.exec())